

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>valis.non_rigid_registrars &mdash; valis &#34;1.2.0&#34;
 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=784e175d"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >

          
          
          <a href="../../index.html">
            
              <img src="https://github.com/MathOnco/valis/raw/main/docs/_images/valis_logo_black_no_bg.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../registration.html">Registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slide_io.html">Slide I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preprocessing.html">Image pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_detectors.html">Feature detectors and descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_matcher.html">Feature matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../affine_optimizer.html">Affine optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../micro_rigid_registrar.html">Micro-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../non_rigid_registrars.html">Non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_rigid.html">Serial rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_non_rigid.html">Serial non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../viz.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">valis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">valis.non_rigid_registrars</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for valis.non_rigid_registrars</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Perform non-rigid registration</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">kornia</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchvision.models.optical_flow</span><span class="w"> </span><span class="kn">import</span> <span class="n">raft_large</span><span class="p">,</span> <span class="n">Raft_Large_Weights</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torchvision.transforms</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">tv_transforms</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">SimpleITK</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sitk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">util</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">color</span> <span class="k">as</span> <span class="n">skcolor</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyvips</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pqdm.threads</span><span class="w"> </span><span class="kn">import</span> <span class="n">pqdm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">viz</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">warp_tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocessing</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">valtils</span>

<span class="n">NR_CLS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_registrar_cls&quot;</span>
<span class="n">NR_PROCESSING_KW_KEY</span> <span class="o">=</span> <span class="s2">&quot;processer_kwargs&quot;</span>
<span class="n">NR_PROCESSING_INIT_KW_KEY</span> <span class="o">=</span> <span class="s2">&quot;init_processer_kwargs&quot;</span>
<span class="n">NR_PROCESSING_CLASS_KEY</span> <span class="o">=</span> <span class="s2">&quot;processer_cls&quot;</span>
<span class="n">NR_STATS_KEY</span> <span class="o">=</span> <span class="s2">&quot;target_stats&quot;</span>
<span class="n">NR_TILE_WH_KEY</span> <span class="o">=</span> <span class="s2">&quot;tile_wh&quot;</span>
<span class="n">NR_PARAMS_KEY</span> <span class="o">=</span> <span class="s2">&quot;params&quot;</span>

<span class="n">NR_MOVING</span> <span class="o">=</span> <span class="s2">&quot;moving&quot;</span>
<span class="n">NR_TILE_MOVING_P_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_MOVING</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_CLASS_KEY</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">NR_TILE_MOVING_P_INIT_KW_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_MOVING</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_INIT_KW_KEY</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">NR_TILE_MOVING_P_KW_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_MOVING</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_KW_KEY</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="n">NR_FIXED</span> <span class="o">=</span> <span class="s2">&quot;fixed&quot;</span>
<span class="n">NR_TILE_FIXED_P_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_FIXED</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_CLASS_KEY</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">NR_TILE_FIXED_P_INIT_KW_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_FIXED</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_INIT_KW_KEY</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">NR_TILE_FIXED_P_KW_KEY</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">NR_FIXED</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">NR_PROCESSING_KW_KEY</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="c1"># Abstract Classes #</span>
<div class="viewcode-block" id="NonRigidRegistrar">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NonRigidRegistrar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for non-rigid registration using displacement fields</span>

<span class="sd">    Warps moving_img to align with fixed_img using backwards transformations</span>
<span class="sd">    VALIS offers 3 implementations: dense optical flow (OpenCV),</span>
<span class="sd">    SimpleElastix, and  groupwise SimpleElastix.</span>
<span class="sd">    Displacement fields can come from other packages, indluding</span>
<span class="sd">    SimpleITK, PIRT, DIPY, etc... Those other methods can be used by</span>
<span class="sd">    subclassing the NonRigidRegistrar classes in VALIS.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : ndarray</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : ndarray</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points.</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    Note</span>
<span class="sd">    -----</span>
<span class="sd">    All NonRigidRegistrar subclasses need to have a calc() method,</span>
<span class="sd">    which must at least take the following arguments:</span>
<span class="sd">    moving_img, fixed_img, mask. calc() should return the displacement field</span>
<span class="sd">    as a (2, N, M) numpy array, with the first element being an array of</span>
<span class="sd">    displacements in the x-dimension, and the second element being an array of</span>
<span class="sd">    displacements in the y-dimension.</span>

<span class="sd">    Note that the NonRigidRegistrarXY subclass should be used if</span>
<span class="sd">    corresponding points in moving and fixed images can be used</span>
<span class="sd">    to aid the registration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NonRigidRegistrar.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rgb</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">rgb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Empty kwargs dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>

        <span class="n">masked_moving</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">masked_fixed</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">masked_moving</span><span class="p">,</span> <span class="n">masked_fixed</span>

<div class="viewcode-block" id="NonRigidRegistrar.calc">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.calc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cacluate displacement fields</span>

<span class="sd">        Can record subclass specific atrributes here too</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`. Has shape (N, M).</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with. Has shape (N, M).</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions. dx = bk_dxdy[0], and dy=bk_dxdy[1].</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">bk_dxdy</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">img_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="n">temp_mask</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2mask</span><span class="p">(</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span>
                                    <span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">)),</span>
                                    <span class="n">temp_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="NonRigidRegistrar.register">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.register">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to NonRigidRegistrar.calc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Moving image registered to align with fixed image.</span>

<span class="sd">        warped_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">moving_shape</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fixed_shape</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">moving_shape</span> <span class="o">==</span> <span class="n">fixed_shape</span><span class="p">),</span> \
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have different shapes&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">moving_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="n">moving_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="n">fixed_img</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only do registration inside mask #</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">masked_fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">mask_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">min_c</span><span class="p">,</span> <span class="n">min_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">max_c</span><span class="p">,</span> <span class="n">max_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="n">masked_moving</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">masked_fixed</span> <span class="o">=</span> <span class="n">masked_fixed</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">masked_fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">moving_img</span><span class="o">=</span><span class="n">masked_moving</span><span class="p">,</span>
                            <span class="n">fixed_img</span><span class="o">=</span><span class="n">masked_fixed</span><span class="p">,</span>
                            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bk_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">bk_dx</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bk_dx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">bk_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">bk_dy</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bk_dy</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bk_dx</span><span class="p">,</span> <span class="n">bk_dy</span><span class="p">])</span>

        <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_warped_img_and_grid</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="n">warp_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">warped_img</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_grid_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an image of a regular grid.</span>

<span class="sd">        Usually used to visualize non-rigid deformations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_spacing : int, optional</span>
<span class="sd">            Number of pixels between grid points.</span>

<span class="sd">        thickness : int, optional</span>
<span class="sd">            Thickness of lines in image.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">grid_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">grid_spacing_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">grid_r</span><span class="p">,</span> <span class="n">grid_c</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
                                      <span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">,</span>
                                      <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>

        <span class="n">grid_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">grid_img</span><span class="p">[</span><span class="n">grid_r</span><span class="p">,</span> <span class="n">grid_c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="k">return</span> <span class="n">grid_img</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_warped_img_and_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply deformation to moving image and regular grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Warped copy of moving image.</span>

<span class="sd">        warp_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to regular grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">)</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="n">warp_grid</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">grid_img</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span></div>



<div class="viewcode-block" id="NonRigidRegistrarXY">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NonRigidRegistrarXY</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for non-rigid registration using displacement fields</span>

<span class="sd">    Subclass of NonRigidRegistrar that can (optionally) use corresponding</span>
<span class="sd">    points (xy coordinates) to aid in the registration</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : ndarray</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : ndarray</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points/</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    moving_xy : ndarray, optional</span>
<span class="sd">        (N, 2) array containing points in `moving_img` that correspond</span>
<span class="sd">        to those in the fixed image.</span>

<span class="sd">    fixed_xy : ndarray, optional</span>
<span class="sd">        (N, 2) array containing points in `fixed_img` that correspond</span>
<span class="sd">        to those in the moving image.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    All NonRigidRegistrarXY subclasses need to have a calc() method,</span>
<span class="sd">    which needs to at least take the following arguments:</span>
<span class="sd">    moving_img, fixed_img, mask, moving_xy, fixed_xy.</span>
<span class="sd">    calc() should return the warped moving image, warped regular grid,</span>
<span class="sd">    and the displacement field as an (2, N, M) numpy array.</span>

<span class="sd">    Note that NonRigidRegistrar should be used if corresponding points in</span>
<span class="sd">    moving and fixed images can not be used to aid the registration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NonRigidRegistrarXY.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the moving image that correspond</span>
<span class="sd">            to those in the fixed image.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the fixed image that correspond</span>
<span class="sd">            to those in the moving image.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_xy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xy</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="NonRigidRegistrarXY.register">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY.register">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the `moving_img` that correspond</span>
<span class="sd">            to those in `fixed_img`.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the `fixed_img` that correspond</span>
<span class="sd">            to those in the `moving_img`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            `moving_img` registered to align with `fixed_img`.</span>

<span class="sd">        warped_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in the</span>
<span class="sd">            x and y directions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_xy</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="p">,</span>
                                                 <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_xy</span> <span class="o">=</span> <span class="n">moving_xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xy</span> <span class="o">=</span> <span class="n">fixed_xy</span>
        <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span> <span class="o">=</span> \
            <span class="n">NonRigidRegistrar</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="o">=</span><span class="n">moving_img</span><span class="p">,</span>
                                       <span class="n">fixed_img</span><span class="o">=</span><span class="n">fixed_img</span><span class="p">,</span>
                                       <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                       <span class="n">moving_xy</span><span class="o">=</span><span class="n">moving_xy</span><span class="p">,</span>
                                       <span class="n">fixed_xy</span><span class="o">=</span><span class="n">fixed_xy</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">filter_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="p">,</span> <span class="n">img_shape_rc</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove points outside image and/or mask</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">img_shape_rc</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">moving_inside_idx</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inside_mask_idx</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">fixed_inside_idx</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inside_mask_idx</span><span class="p">(</span><span class="n">fixed_xy</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">inside_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">moving_inside_idx</span><span class="p">,</span> <span class="n">fixed_inside_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moving_xy</span><span class="p">[</span><span class="n">inside_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">fixed_xy</span><span class="p">[</span><span class="n">inside_idx</span><span class="p">,</span> <span class="p">:]</span></div>



<div class="viewcode-block" id="NonRigidRegistrarGroupwise">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NonRigidRegistrarGroupwise</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs groupwise non-rigid registration</span>

<span class="sd">    This subclass can register a collection (&gt;= 2) of images,</span>
<span class="sd">    and so is not limited to pairs of images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    img_list : list of ndarray</span>
<span class="sd">        List of images, each with shape (N,M) that are to be co-registered</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple of int</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    size : int</span>
<span class="sd">        Number of images that are being registered as a group</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NonRigidRegistrarGroupwise.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply mask to all images in img_list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">:</span>
            <span class="n">temp_mask</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2mask</span><span class="p">(</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span>
                                    <span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">)),</span>
                                    <span class="n">temp_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="NonRigidRegistrarGroupwise.register">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise.register">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register images in img_list</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img_list : list of ndarray</span>
<span class="sd">            List of I images, each with shape (N,M) that are to</span>
<span class="sd">            be co-registered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : list of ndarray</span>
<span class="sd">            List of moving images registered to align with the fixed image.</span>

<span class="sd">        warped_grid : list of ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : list of ndarray</span>
<span class="sd">            List numpy array of pixel displacements in the x and y directions</span>
<span class="sd">            for each image. Has shape (I, N, M, 2).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have differernt shapes&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span> <span class="o">=</span> <span class="n">img_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">mask_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">min_c</span><span class="p">,</span> <span class="n">min_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">max_c</span><span class="p">,</span> <span class="n">max_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">temp_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">):</span>

                <span class="n">temp_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp_img_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span>

        <span class="n">backward_deformations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">temp_img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temp_backward_deformations</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">bk_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">bk_dx</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bk_dx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">bk_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">bk_dy</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">bk_dy</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">temp_backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bk_dx</span><span class="p">,</span> <span class="n">bk_dy</span><span class="p">])</span>

            <span class="n">backward_deformations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp_backward_deformations</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">n_imgs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">)</span>
        <span class="n">warp_maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">get_warp_map</span><span class="p">(</span><span class="n">dxdy</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="n">warped_imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">warp_maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="n">warped_grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">grid_img</span><span class="p">,</span> <span class="n">warp_maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">warped_imgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="n">warped_grids</span>

        <span class="k">return</span> <span class="n">warped_imgs</span><span class="p">,</span> <span class="n">warped_grids</span><span class="p">,</span> <span class="n">backward_deformations</span></div>
</div>



<span class="c1"># Class members that perform non-rigid registrations #</span>
<div class="viewcode-block" id="SimpleElastixWarper">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleElastixWarper</span><span class="p">(</span><span class="n">NonRigidRegistrarXY</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Uses SimpleElastix to register images</span>

<span class="sd">    May optionally using corresponding points</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleElastixWarper.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ammi_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
                 <span class="n">bending_penalty_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">kp_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ammi_weight : float</span>
<span class="sd">            Weight given to the AdvancedMattesMutualInformation metric.</span>

<span class="sd">        bending_penalty_weight : float</span>
<span class="sd">            Weight given to the TransformBendingEnergyPenalty metric.</span>

<span class="sd">        kp_weight : float</span>
<span class="sd">            Weight given to the CorrespondingPointsEuclideanDistanceMetric</span>
<span class="sd">            metric. Only used if moving_xy and fixed_xy are provided as</span>
<span class="sd">            arguments to the `register()` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span> <span class="o">=</span> <span class="n">ammi_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span> <span class="o">=</span> <span class="n">bending_penalty_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kp_weight</span> <span class="o">=</span> <span class="n">kp_weight</span></div>



<div class="viewcode-block" id="SimpleElastixWarper.get_default_params">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.get_default_params">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_default_params</span><span class="p">(</span><span class="n">img_shape</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get default parameters for registration with sitk.ElastixImageFilter</span>

<span class="sd">        See https://simpleelastix.readthedocs.io/Introduction.html</span>
<span class="sd">        for advice on parameter selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetDefaultParameterMap</span><span class="p">(</span><span class="s2">&quot;bspline&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AdvancedMattesMutualInformation&#39;</span><span class="p">,</span> <span class="s1">&#39;TransformBendingEnergyPenalty&#39;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MaximumNumberOfIterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1500&#39;</span><span class="p">]</span>  <span class="c1"># Can try up to 2000</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;FixedImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;FixedRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;MovingImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MovingRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;Interpolator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BSplineInterpolator&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ImageSampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;RandomCoordinate&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MetricSamplingStrategy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;None&quot;</span><span class="p">]</span>  <span class="c1"># Use all points</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;UseRandomSampleRegion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ErodeMask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfHistogramBins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;32&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfSpatialSamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;3000&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NewSamplesEveryIteration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;SampleRegionSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">]))]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AdaptiveStochasticGradientDescent&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ASGDParameterEstimationMethod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementDistribution&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">grid_spacing_x</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing_y</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">grid_spacing_x</span><span class="p">,</span> <span class="n">grid_spacing_y</span><span class="p">])))</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_spacing</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;WriteResultImage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">elastix_invert_transform</span><span class="p">(</span><span class="n">registed_elastix_obj</span><span class="p">,</span> <span class="n">sitk_fixed</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invert transformation as described in elastix manual.</span>

<span class="sd">        See section 6.1.6: DisplacementMagnitudePenalty: inverting transformations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        registed_elastix_obj: sitk.ElastixImageFilter</span>
<span class="sd">            sitk.ElastixImageFilter object that has completed</span>
<span class="sd">            image registration.</span>

<span class="sd">        sitk_fixed : SimpleITK.Image</span>
<span class="sd">            SimpleITK.Image created from the fixed image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverted_deformationField : ndarray</span>
<span class="sd">            (N,M,2) numpy array of pixel displacements in the</span>
<span class="sd">            x and y directions.</span>

<span class="sd">        NOTE</span>
<span class="sd">        ----</span>
<span class="sd">        sitk.IterativeInverseDisplacementField seems to do a better job,</span>
<span class="sd">        and is what is used in warp_tools.get_inverse_field. However, this</span>
<span class="sd">        method is maintained in case one would like to use it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inverse_transformationFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transf_parameter_map</span> <span class="o">=</span> <span class="n">registed_elastix_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">()</span>
        <span class="n">transf_parameter_map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementMagnitudePenalty&quot;</span><span class="p">]</span>
        <span class="n">transf_parameter_map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk_fixed</span><span class="p">)</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">transf_parameter_map</span><span class="p">)</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">inverted_deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">inverted_deformationField</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_elastix_kp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Temporarily write fixed_xy and moving_xy to file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kp: ndarray</span>
<span class="sd">            (N, 2) numpy array of points (xy).</span>

<span class="sd">        fname: str</span>
<span class="sd">            Name of file in which to save the points.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">argfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">argfile</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index</span><span class="se">\n</span><span class="si">{</span><span class="n">npts</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">kp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">argfile</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_elastix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run SimpleElastix to register images.</span>

<span class="sd">        Can using corresponding points to aid in registration by providing</span>
<span class="sd">        moving_xy and fixed_xy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the moving image that correspond</span>
<span class="sd">            to those in the fixed image.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the fixed image that correspond</span>
<span class="sd">            to those in the moving image.</span>

<span class="sd">        mask : ndarray, optional</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are</span>
<span class="sd">            foreground, and 0 is background, which is ignnored during</span>
<span class="sd">            registration. If None, then all non-zero pixels in images</span>
<span class="sd">            will be used to create the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">elastix_image_filter_obj</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ElastixImageFilter</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixed_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rand_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
            <span class="n">fixed_kp_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                          <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">rand_id</span><span class="si">}</span><span class="s2">_fixedPointSet.pts&quot;</span><span class="p">)</span>
            <span class="n">moving_kp_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                           <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">rand_id</span><span class="si">}</span><span class="s2">_.movingPointSet.pts&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">write_elastix_kp</span><span class="p">(</span><span class="n">fixed_xy</span><span class="p">,</span> <span class="n">fixed_kp_fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_elastix_kp</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">moving_kp_fname</span><span class="p">)</span>

            <span class="n">kp_dist_met</span> <span class="o">=</span> <span class="s2">&quot;CorrespondingPointsEuclideanDistanceMetric&quot;</span>
            <span class="n">current_metrics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="ow">or</span> <span class="n">kp_dist_met</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_metrics</span><span class="p">:</span>
                <span class="n">current_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kp_dist_met</span><span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_metrics</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">kp_weight</span><span class="p">])</span>

            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedPointSetFileName</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingPointSetFileName</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span><span class="p">])</span>

        <span class="c1"># Set metric weights #</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_metrics</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">])</span>
        <span class="n">n_res</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;NumberOfResolutions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_metrics</span><span class="p">):</span>
            <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Metric</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1">Weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">])]</span><span class="o">*</span><span class="n">n_res</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Perform registration #</span>
        <span class="n">sitk_moving</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>
        <span class="n">sitk_fixed</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk_moving</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedImage</span><span class="p">(</span><span class="n">sitk_fixed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sitk_mask</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">Cast</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)),</span>
                                  <span class="n">sitk</span><span class="o">.</span><span class="n">sitkUInt8</span><span class="p">)</span>

            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedMask</span><span class="p">(</span><span class="n">sitk_mask</span><span class="p">)</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>

        <span class="c1"># Get deformation field #</span>
        <span class="n">transformixImageFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">())</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())</span>

        <span class="c1"># Warp image #</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">()</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">resultImage</span><span class="p">)</span>

        <span class="c1"># Get deformation grid #</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">grid_img</span><span class="p">))</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">warped_grid</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixed_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">)</span>

        <span class="n">tform_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;TransformParameters.&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tform_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tform_files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resultImage</span><span class="p">,</span> <span class="n">warped_grid</span><span class="p">,</span> <span class="n">deformationField</span><span class="p">,</span> <span class="n">elastix_image_filter_obj</span><span class="p">,</span> <span class="n">transformixImageFilter</span>

<div class="viewcode-block" id="SimpleElastixWarper.calc">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.calc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform non-rigid registration using SimpleElastix.</span>

<span class="sd">        Can include corresponding points to help in registration by providing</span>
<span class="sd">        `moving_xy` and `fixed_xy`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">fixed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>\
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have different shapes&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">warped_img</span><span class="p">,</span> \
            <span class="n">warped_grid</span><span class="p">,</span> \
            <span class="n">backward_deformation</span><span class="p">,</span> \
            <span class="n">backward_elastix_image_filter_obj</span><span class="p">,</span> \
            <span class="n">backward_transformixImageFilter</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">run_elastix</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span>
                             <span class="n">moving_xy</span><span class="o">=</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="n">fixed_xy</span><span class="p">,</span>
                             <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Record other params #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastix_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Can&#39;t pickle SimpleITK.ParameterMap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">backward_elastix_image_filter_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">backward_deformation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">backward_deformation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">dxdy</span></div>
</div>



<div class="viewcode-block" id="OpticalFlowWarper">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OpticalFlowWarper</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use dense optical flow to register images.</span>

<span class="sd">    Dense optical flow fields may not be diffeomorphic, and so</span>
<span class="sd">    this class provides options to smooth displacement fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OpticalFlowWarper.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optical_flow_obj</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">optflow</span><span class="o">.</span><span class="n">createOptFlow_DeepFlow</span><span class="p">(),</span>
                 <span class="n">n_grid_pts</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">sigma_ratio</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                 <span class="n">paint_size</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">fold_penalty</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">smoothing_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">        optical_flow_obj : object</span>
<span class="sd">            Object that will perform dense optical flow.</span>

<span class="sd">        n_grid_pts : int</span>
<span class="sd">            Number of gridpoints used to detect folds. Also the number</span>
<span class="sd">            of gridpoints to use when regularizing he mesh when</span>
<span class="sd">            `method` = &quot;regularize&quot;.</span>

<span class="sd">        paint_size : int</span>
<span class="sd">            Used to determine how much to resize the image to have</span>
<span class="sd">            efficient inpainting. Larger values = longer processing time.</span>
<span class="sd">            Only used if `smoothing_method` = &quot;inpaint&quot;.</span>

<span class="sd">        fold_penalty : float</span>
<span class="sd">            How much to penalize folding/stretching. Larger values will make</span>
<span class="sd">            the deformation field more uniform, which may or may not be</span>
<span class="sd">            desired, as too much can remove all displacements.</span>
<span class="sd">            Only used if `smoothing_method` = &quot;regularize&quot;</span>

<span class="sd">        sigma_ratio : float</span>
<span class="sd">            Determines the amount of Gaussian smoothing, as</span>
<span class="sd">            sigma = max(shape) *sigma_ratio. Larger values do more</span>
<span class="sd">            smoothing. Only used if `smoothing_method` is &quot;gauss&quot;.</span>

<span class="sd">        smoothing : str</span>
<span class="sd">            If &quot;gauss&quot;, then a Gaussian blur will be applied to the</span>
<span class="sd">            deformation fields, using sigma defined by sigma_ratio.</span>

<span class="sd">            If &quot;inpaint&quot;, folded regions will be detected and removed.</span>
<span class="sd">            Folded regions will then be removed using inpainting.</span>

<span class="sd">            If &quot;regularize&quot;, folded regions will be detected and</span>
<span class="sd">            regularized using the method fescribed in</span>
<span class="sd">            &quot;Foldover-free maps in 50 lines of code&quot; Garanzha et al. 2021.</span>

<span class="sd">            If &quot;None&quot; then no smoothing will be applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">=</span> <span class="n">smoothing_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_ratio</span> <span class="o">=</span> <span class="n">sigma_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paint_size</span> <span class="o">=</span> <span class="n">paint_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fold_penalty</span> <span class="o">=</span> <span class="n">fold_penalty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span> <span class="o">=</span> <span class="n">n_grid_pts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">optical_flow_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flow_obj</span> <span class="o">=</span> <span class="n">optical_flow_obj</span></div>


<div class="viewcode-block" id="OpticalFlowWarper.calc">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper.calc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;createOptFlow_DenseRLOF&#39;</span><span class="p">,</span> <span class="s1">&#39;createOptFlow_SimpleFlow&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">moving_img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fixed_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fixed_img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>

        <span class="n">backward_flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_flow_obj</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">backward_flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">backward_flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;gauss&quot;</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">smooth_dx</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">smooth_dy</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smooth_dx</span><span class="p">,</span> <span class="n">smooth_dy</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;inpaint&quot;</span><span class="p">:</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">remove_folds_in_dxdy</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">,</span>
                                                            <span class="n">n_grid_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span><span class="p">,</span>
                                                            <span class="n">paint_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paint_size</span><span class="p">,</span>
                                                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;regularize&quot;</span><span class="p">:</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">untangle</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">,</span>
                                                <span class="n">n_grid_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span><span class="p">,</span>
                                                <span class="n">penalty</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fold_penalty</span><span class="p">,</span>
                                                <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">)</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">RAFTWarper</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use dense optical flow to register images.</span>

<span class="sd">    Dense optical flow fields may not be diffeomorphic, and so</span>
<span class="sd">    this class provides options to smooth displacement fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">Raft_Large_Weights</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">transform_method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rgb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quant_img</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : str</span>
<span class="sd">            Weights to use. See `torchvision.models.optical_flow.Raft_Large_Weights`</span>
<span class="sd">            for options.</span>

<span class="sd">        transform_method : str</span>
<span class="sd">            How to transform the image so that it&#39;s dimensions are divisible by 8.</span>
<span class="sd">            &quot;pad&quot; will pad the image with 0s, &quot;resize&quot; will resize the image.</span>
<span class="sd">            These transformations are removed from the displacement fields</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rgb</span><span class="o">=</span><span class="n">rgb</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quant_img</span> <span class="o">=</span> <span class="n">quant_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_method</span> <span class="o">=</span> <span class="n">transform_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">raft_large</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">prep_img_for_raft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">dim_div</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        3 channels. Dimensions divisible by 8</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">img3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">[</span><span class="n">img</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant_img</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;quantizing image for non-rigid registration&quot;</span><span class="p">)</span>
                <span class="n">img3d</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">quantize_image</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img3d</span> <span class="o">=</span> <span class="n">img</span>

        <span class="n">torch_img</span> <span class="o">=</span> <span class="n">tv_transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">()(</span><span class="n">img3d</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">torch_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">h_pad</span> <span class="o">=</span> <span class="n">dim_div</span> <span class="o">-</span> <span class="n">h</span> <span class="o">%</span> <span class="n">dim_div</span>
        <span class="n">w_pad</span> <span class="o">=</span> <span class="n">dim_div</span> <span class="o">-</span> <span class="n">w</span> <span class="o">%</span> <span class="n">dim_div</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span><span class="p">:</span>
            <span class="c1"># Pad image</span>
            <span class="n">lpad</span> <span class="o">=</span> <span class="n">w_pad</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">rpad</span> <span class="o">=</span> <span class="n">w_pad</span> <span class="o">-</span> <span class="n">lpad</span>
            <span class="n">tpad</span> <span class="o">=</span> <span class="n">h_pad</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">bpad</span> <span class="o">=</span> <span class="n">h_pad</span> <span class="o">-</span> <span class="n">tpad</span>

            <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpad</span><span class="p">,</span> <span class="n">tpad</span><span class="p">,</span> <span class="n">rpad</span><span class="p">,</span> <span class="n">bpad</span><span class="p">]</span> <span class="c1"># left, top, right and bottom</span>
            <span class="n">transformed_img</span> <span class="o">=</span> <span class="n">tv_transforms</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">padding</span><span class="p">)(</span><span class="n">torch_img</span><span class="p">)</span>
            <span class="n">img_transform</span> <span class="o">=</span> <span class="n">padding</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Resize image</span>
            <span class="n">out_h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">h_pad</span>
            <span class="n">out_w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">w_pad</span>
            <span class="n">transformed_img</span> <span class="o">=</span> <span class="n">tv_transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">out_h</span><span class="p">,</span> <span class="n">out_w</span><span class="p">],</span> <span class="n">antialias</span><span class="o">=</span><span class="kc">False</span><span class="p">)(</span><span class="n">torch_img</span><span class="p">)</span>
            <span class="n">img_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">out_w</span><span class="o">/</span><span class="n">w</span><span class="p">,</span> <span class="n">out_h</span><span class="o">/</span><span class="n">h</span><span class="p">])</span> <span class="c1"># Scaling in x, y</span>

        <span class="n">transformed_img_h</span><span class="p">,</span> <span class="n">transformed_img_w</span> <span class="o">=</span> <span class="n">transformed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="n">transformed_img_h</span> <span class="o">%</span> <span class="n">dim_div</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">transformed_img_w</span> <span class="o">%</span> <span class="n">dim_div</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">transformed_img</span><span class="p">,</span> <span class="n">img_transform</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">transformed_moving_img</span><span class="p">,</span> <span class="n">moving_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_img_for_raft</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_method</span><span class="p">)</span>
        <span class="n">transformed_fixed_img</span><span class="p">,</span> <span class="n">fixed_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_img_for_raft</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_method</span><span class="p">)</span>

        <span class="n">transformed_moving_img</span><span class="p">,</span> <span class="n">transformed_fixed_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">()(</span><span class="n">transformed_moving_img</span><span class="p">,</span> <span class="n">transformed_fixed_img</span><span class="p">)</span>

        <span class="n">list_of_flows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">transformed_fixed_img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> <span class="n">transformed_moving_img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">))</span>
        <span class="n">dxdy</span> <span class="o">=</span> <span class="n">list_of_flows</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">moving_transform</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Remove padding</span>
            <span class="n">lp</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">moving_transform</span>
            <span class="n">cropped_dx</span> <span class="o">=</span> <span class="n">dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">tp</span><span class="p">:</span><span class="n">dxdy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bp</span><span class="p">,</span> <span class="n">lp</span><span class="p">:</span><span class="n">dxdy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">rp</span><span class="p">]</span>
            <span class="n">cropped_dy</span> <span class="o">=</span> <span class="n">dxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">tp</span><span class="p">:</span><span class="n">dxdy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bp</span><span class="p">,</span> <span class="n">lp</span><span class="p">:</span><span class="n">dxdy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">rp</span><span class="p">]</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cropped_dx</span><span class="p">,</span> <span class="n">cropped_dy</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">moving_transform</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Resize dxdy</span>
            <span class="n">scaled_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">scale_dxdy</span><span class="p">(</span><span class="n">dxdy</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scaled_dxdy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">scaled_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">scaled_dxdy</span><span class="p">)</span>

            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scaled_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">scaled_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">backward_flow</span>


<div class="viewcode-block" id="SimpleElastixGroupwiseWarper">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleElastixGroupwiseWarper</span><span class="p">(</span><span class="n">NonRigidRegistrarGroupwise</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs groupwise non-rigid registration using SimpleElastix.</span>

<span class="sd">    SimpleElastixGroupwiseWarper can register a collection (&gt;= 2) of images,</span>
<span class="sd">    and so is not limited to pairs of images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    img_list : list</span>
<span class="sd">        List of images, each with shape (N,M) that are to be co-registered.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple of int</span>
<span class="sd">        Number of rows and columns in each image.</span>
<span class="sd">        Will have shaape (N,M).</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.__init__">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.get_default_params">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.get_default_params">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_default_params</span><span class="p">(</span><span class="n">img_shape</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See https://simpleelastix.readthedocs.io/Introduction.html for advice on parameter selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetDefaultParameterMap</span><span class="p">(</span><span class="s2">&quot;groupwise&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AdvancedMattesMutualInformation&#39;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MaximumNumberOfIterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1500&#39;</span><span class="p">]</span>  <span class="c1"># Can try up to 2000</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;FixedImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;FixedRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;MovingImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MovingRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ImageSampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;RandomCoordinate&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MetricSamplingStrategy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;None&quot;</span><span class="p">]</span>  <span class="c1"># Use all points</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;UseRandomSampleRegion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ErodeMask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfSpatialSamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;3000&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NewSamplesEveryIteration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AdaptiveStochasticGradientDescent&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ASGDParameterEstimationMethod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementDistribution&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">grid_spacing_x</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing_y</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">grid_spacing_x</span><span class="p">,</span> <span class="n">grid_spacing_y</span><span class="p">])))</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_spacing</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;WriteResultImage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span></div>


<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.calc">
<a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.calc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">SimpleElastixGroupwiseWarper</span><span class="o">.</span><span class="n">get_default_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">vectorOfImages</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="n">vectorOfImages</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfImages</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ElastixImageFilter</span><span class="p">()</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vectorOfMasks</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)):</span>
                <span class="n">vectorOfMasks</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">mask3d</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfMasks</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedMask</span><span class="p">(</span><span class="n">mask3d</span><span class="p">)</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>

        <span class="c1"># Get warped images #</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">()</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">resultImage</span><span class="p">)</span>

        <span class="c1"># Get deformation fields #</span>
        <span class="n">transformixImageFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">())</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Get deformation grid #</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastix_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Can&#39;t pickle SimpleITK.ParameterMap</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="n">vectorOfGrids</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)):</span>
            <span class="n">vectorOfGrids</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">grid_img</span><span class="p">))</span>
        <span class="n">grid3d</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfGrids</span><span class="p">)</span>

        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">grid3d</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">warped_grid</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">())</span>

        <span class="n">tform_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;TransformParameters.&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tform_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tform_files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">deformationField</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                                      <span class="n">deformationField</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]]</span>
                                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deformationField</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">deformationField</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">NonRigidTileRegistrar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tile-wise non-rigid regisration</span>

<span class="sd">    Slices moving and fixed images into tiles and then registers each tile.</span>
<span class="sd">    Probably best for very large images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : pyvips.Image</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : pyvips.Image</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : pyvips.Image</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    bk_dxdy_tiles : list</span>
<span class="sd">        List of bk_dxdy for each tile</span>

<span class="sd">    bk_dxdy : pyvips.Image</span>
<span class="sd">        Backwards isplacement field after stitching `bk_dxdy_tiles` together</span>

<span class="sd">    fwd_dxdy_tiles : list</span>
<span class="sd">        List of forward dxdy for each tile</span>

<span class="sd">    fwd_dxdy : pyvips.Image</span>
<span class="sd">        Displacement field after stitching `fwd_dxdy_tiles` together</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_wh</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">tile_buffer</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used when initializing the `non_rigid_registrar_cls`</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        tile_wh : int</span>
<span class="sd">            Width and height of tiles that will be used for registration</span>

<span class="sd">        tile_buffer : int</span>
<span class="sd">            The amount of overlap between each tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span> <span class="o">=</span> <span class="n">tile_buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">norm_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">norm_img_stats</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">target_stats</span><span class="o">=</span><span class="n">stats</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">normed_img</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">norm_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">target_processing_stats</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">collect_img_stats</span><span class="p">([</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">])</span>
            <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="n">target_processing_stats</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">tile_mask</span><span class="p">)</span>
            <span class="n">moving_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">target_processing_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Norm using full image&#39;s stats</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>
                    <span class="n">moving_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">fixed_normed</span> <span class="o">=</span> <span class="n">fixed_img</span>
                    <span class="n">moving_normed</span> <span class="o">=</span> <span class="n">moving_img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixed_normed</span> <span class="o">=</span> <span class="n">fixed_img</span>
                <span class="n">moving_normed</span> <span class="o">=</span> <span class="n">moving_img</span>

        <span class="k">return</span> <span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">img_processer_cls</span><span class="p">,</span> <span class="n">processer_init_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">processer_kwargs</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">processer_init_kwargs</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
        <span class="n">processer_init_kwargs</span><span class="p">[</span><span class="s1">&#39;reader&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">processer_init_kwargs</span><span class="p">[</span><span class="s2">&quot;reader&quot;</span><span class="p">])</span>
        <span class="n">processer_init_kwargs</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processer</span> <span class="o">=</span> <span class="n">img_processer_cls</span><span class="p">(</span><span class="o">**</span><span class="n">processer_init_kwargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processer</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="o">**</span><span class="n">processer_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># processor.process_image doesn&#39;t take kwargs</span>
            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processer</span><span class="o">.</span><span class="n">process_image</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">processed_img</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reg_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_idx</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>

            <span class="c1"># Use lock when accessing images</span>
            <span class="n">tile_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span>
            <span class="n">moving_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>
            <span class="n">fixed_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>

            <span class="n">np_fixed</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">fixed_tile</span><span class="p">)</span>
            <span class="n">np_moving</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">moving_tile</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tile_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>
                <span class="n">np_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">tile_mask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np_mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">interpretation</span> <span class="o">==</span> <span class="s2">&quot;srgb&quot;</span><span class="p">:</span>
                <span class="c1"># Limit registration to be inside image</span>
                <span class="c1"># Warped areas outside image have the same pixel values, usually 0</span>
                <span class="n">edge_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="p">((</span><span class="n">np_moving</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np_moving</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np_fixed</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np_fixed</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">np_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="p">((</span><span class="n">edge_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">np_mask</span> <span class="o">=</span> <span class="n">edge_mask</span>

            <span class="c1"># Check if either of the tiles are empty</span>
            <span class="n">is_empty</span> <span class="o">=</span> <span class="n">fixed_tile</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">fixed_tile</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="ow">or</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">is_empty</span> <span class="o">=</span> <span class="n">is_empty</span> <span class="ow">or</span> <span class="n">np_mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">is_empty</span><span class="p">:</span>
                <span class="c1"># Nothing to register</span>
                <span class="n">empty_dxdy</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">moving_tile</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_dxdy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_dxdy</span>

                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Process tiles</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">moving_processed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tile</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">np_moving</span><span class="p">,</span>
                                                    <span class="n">img_processer_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_cls</span><span class="p">,</span>
                                                    <span class="n">processer_init_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_init_kwargs</span><span class="p">,</span>
                                                    <span class="n">processer_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_kwargs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np_moving</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">moving_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">skcolor</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">np_moving</span><span class="p">))</span>
                    <span class="n">moving_processed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">moving_g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">moving_processed</span> <span class="o">=</span> <span class="n">np_moving</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fixed_processed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tile</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">np_fixed</span><span class="p">,</span>
                                            <span class="n">img_processer_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_cls</span><span class="p">,</span>
                                            <span class="n">processer_init_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_init_kwargs</span><span class="p">,</span>
                                            <span class="n">processer_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np_fixed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">fixed_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">skcolor</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">np_fixed</span><span class="p">))</span>
                    <span class="n">fixed_processed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">fixed_g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed_processed</span> <span class="o">=</span> <span class="n">np_fixed</span>

            <span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_tiles</span><span class="p">(</span><span class="n">moving_processed</span><span class="p">,</span> <span class="n">fixed_processed</span><span class="p">,</span> <span class="n">np_mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span><span class="p">):</span>
                <span class="c1"># Need to instantiate object</span>
                <span class="n">tile_non_rigid_reg_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># self.non_rigid_registrar_cls is already instantiated</span>
                <span class="n">tile_non_rigid_reg_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">tile_non_rigid_reg_obj</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span><span class="p">)</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inverse_field</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>

            <span class="n">vips_tile_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
            <span class="n">vips_tile_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">fwd_dxdy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vips_tile_bk_dxdy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vips_tile_fwd_dxdy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cacluate displacement fields</span>
<span class="sd">        Each tile is registered and then stitched together</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;======== Registering tiles</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_ncpus_available</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">lock</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;tile_idx&quot;</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;lock&quot;</span><span class="p">:</span><span class="n">lock</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">)]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pqdm</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_tile</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argument_type</span><span class="o">=</span><span class="s1">&#39;kwargs&#39;</span><span class="p">)</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">stitch_tiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">)</span>
        <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">stitch_tiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">fwd_dxdy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non_rigid_registrar_cls</span><span class="o">=</span><span class="n">OpticalFlowWarper</span><span class="p">,</span>
                 <span class="n">moving_processer_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moving_init_processer_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">moving_processer_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixed_processer_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_init_processer_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">fixed_processer_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_stats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray, pyvips.Image</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray, pyvips.Image</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray, pyvips.Image</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        non_rigid_registrar_cls : NonRigidRegistrar, optional</span>
<span class="sd">            Uninstantiated NonRigidRegistrar class that will be used</span>
<span class="sd">            to calculate the deformation fields between images.</span>

<span class="sd">        processing_cls : preprocessing.ImageProcesser, optional</span>
<span class="sd">            preprocessing.ImageProcesser used to process the images</span>

<span class="sd">        processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `processing_cls`</span>

<span class="sd">        target_stats : ndarray</span>
<span class="sd">            Target stats used to normalize each tile after being processed.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to NonRigidRegistrar.calc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : pyvips.Image</span>
<span class="sd">            Moving image registered to align with fixed image.</span>

<span class="sd">        fwd_dxdy :</span>
<span class="sd">            (2, N, M)  pyvips.Image with pixel displacements in</span>
<span class="sd">            the x and y directions. Found by registering `moving_img`</span>
<span class="sd">            to `fixed_img`. Used for point warping</span>

<span class="sd">        bk_dxdy : pyvips.Image</span>
<span class="sd">            (2, N, M)  pyvips.Image with pixel displacements in</span>
<span class="sd">            the x and y directions. Found by registering `fixed_img` to</span>
<span class="sd">            `moving_img`. Used for image warping</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">moving_img</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">width</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape_rc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="n">non_rigid_registrar_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span> <span class="o">=</span> <span class="n">target_stats</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_cls</span> <span class="o">=</span> <span class="n">moving_processer_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_kwargs</span> <span class="o">=</span> <span class="n">moving_processer_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_processer_init_kwargs</span> <span class="o">=</span> <span class="n">moving_init_processer_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_cls</span> <span class="o">=</span> <span class="n">fixed_processer_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_kwargs</span> <span class="o">=</span> <span class="n">fixed_processer_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_processer_init_kwargs</span> <span class="o">=</span> <span class="n">fixed_init_processer_kwargs</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">moving_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="n">fixed_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="n">moving_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="n">fixed_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="n">temp_tile_bboxes</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_grid_bboxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">expand_bbox</span><span class="p">(</span><span class="n">bbox_xywh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox_xywh</span> <span class="ow">in</span> <span class="n">temp_tile_bboxes</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">()</span>

        <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="p">[</span><span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">warped_img</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">bk_dxdy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">fwd_dxdy</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">fwd_dxdy</span><span class="p">,</span> <span class="n">bk_dxdy</span>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2025, Chandler Gatenbee.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>